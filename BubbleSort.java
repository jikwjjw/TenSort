package sort;

import java.util.Arrays;

import org.junit.Test;

/**
 * 冒泡排序(大的值从前往后冒泡)
 * 比较两个相邻的元素，将值大的元素交换到右边
 * 1.首先比较第一和第二个数，将小数放在前面，将大数放在后面
 * 2.比较第2和第3个数，将小数 放在前面，大数放在后面。
 * 3.如此继续，知道比较到最后的两个数，将小数放在前面，大数放在后面，重复步骤，直至全部排序完成 
 * 在上面一趟比较完成后，最后一个数一定是数组中最大的一个数，所以在比较第二趟的时候，最后一个数是不参加比较的。
 * 在第二趟比较完成后，倒数第二个数也一定是数组中倒数第二大数，所以在第三趟的比较中，最后两个数是不参与比较的。
 * 依次类推，每一趟比较次数减少依次
 * @author ji
 * 冒泡排序的优点：每进行一趟排序，就会少比较一次，因为每进行一趟排序都会找出一个较大值。如上例：第一趟比较之后，排在最后的一个数一定是最大的一个数，第二趟排序的时候，只需要比较除了最后一个数以外的其他的数，同样也能找出一个最大的数排在参与第二趟比较的数后面，第三趟比较的时候，只需要比较除了最后两个数以外的其他的数，以此类推……也就是说，没进行一趟比较，每一趟少比较一次，一定程度上减少了算法的量
 * 如果我们的数据正序，只需要走一趟即可完成排序,冒泡排序最好的时间复杂度为O(n)。
 * 数据是反序的，则需要进行n-1趟排序。每趟排序要进行n-i次比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。冒泡排序最好的时间复杂度为O(n^2)。
 * 
 */
public class BubbleSort {
	public int[] bubbleSort(int[] arr){
		for(int i=0;i<arr.length-1;i++){//第i趟比较
			for(int j=0;j<arr.length-i-1;j++){//j<arr.length-i,最后一个数一定是最大的
				//开始进行比较，如果arr[j]比arr[j+1]的值大，那就交换位置
                if(arr[j]>arr[j+1]){
                    int temp=arr[j];
                    arr[j]=arr[j+1];
                    arr[j+1]=temp;
                }
			}
		}
		return arr;
	}
	
	@Test
	public void test(){
		int[] arr ={1,10,35,61,89,36,55};
		System.out.println(Arrays.toString(bubbleSort(arr)));
	}
}
